### 3806.Maximum-Bitwise-AND-After-Increment-Operations

因为bitwise AND的性质是数越多结果反而越小。要想最终结果最大，显然需要在尽量高的位置上，所有数组元素在该处的bit值都是1.

于是我们就有显然的贪心策略：优先探索能否把所有元素的最高（即第30号）bit位都变成1（注意：整型的第31号bit位是符号位），也就是将“100...0”定为目标值。我们可以计算将所有元素变成该target所需要的最少操作数，如果成功，那么实现该效果的所有操作是必须保留的。因为不做这些操作，bitwise AND的第30号位就不是1，结果不可能更优。

接下来在此基础上，我们自然就会考察下一个位置：能否把所有元素的第29号bit位都变成1。如果前一步的尝试是成功的，此时就将“110...0”定为目标值；如果前一步不能实现，此时就将“010...0”定为目标值。同样，我们可以计算出所有元素变成该target所需要的最少操作数，以及是否能实现。

以此类推，我们可以找到最优且可行的target，使得所有数组元素可以在指定的操作范围内，都变成target（更确切的说是`target & num == target`）。自然最终的bitwise AND的结果也是target。

想到这里，我们需要处理的一个子问题就是，对于一个数num，需要最少增加多少，才能使得`target & num == target`？同样需要从最高位往低逐位判定。如果target的第p位是1，但是num的第p位是0，那么我们就必须动作起来，将num的p位后缀"0xx...xx"至少增长至"100...000"，其中的差值就是需要的增1操作数。注意，此时我们需要更新num，以反应我们的增1操作的效果。接下来我们考察下一个bit位，当出现同样的判定条件时（即target的第p位是1，但是num的第p位是0），做同样的增1操作。
