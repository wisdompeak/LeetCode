### 264.Ugly-Number-II


此题的常规解法是类似BFS。对于当前ugly number的某一个元素k，由它可以生成另外三个ugly number，分别是k\*2,k\*3,k\*5，于是将这三个数添加进队列，注意需要做去重和自动排序。所以这样的数据结构用set比较好。这样的时间复杂度是o(NlogN).

事实上有更好的解法，时间复杂度是o(N).上面的解法的问题在于，对于k\*2,k\*3,k\*5，他们的差距可能很大，加入BFS队列的时候也并不都放在最后，可能需要排序才能插入到合适的位置。如何避免这样的排序呢？也就是说，如何生成下一个丑数，使得这个新成员肯定是比之前的丑数都大，继而不需要排序就可以直接放在最后？

我们思考，对于任何丑数，它只能由某一个丑数乘以2，或者某一个丑数乘以3，或者某一个丑数乘以5得到。OK，假设有三个丑数a,b,c,它们对应的a\*2,b\*3,c\*5,如果这三个都是新数，我们必然就只先取最小的那个，假设是a\*2，OK，可以放入队列。那么这时候我们想一想，下一个最小的、并且靠\*2得到的丑数会是什么呢？必然是丑数a的下一个丑数（指对于index而言）a'再乘以2. 下一个最小的、并且靠\*3得到的丑数会是什么呢？依然是b\*3。同理下一个最小的、并且靠\*5得到的丑数会是什么呢？依然是c\*5。进一步，那整个队列下一个最小的丑数是什么呢？因为丑数只可能是靠\*2，\*3，或者\*5得到，所以它有三个候选，那就是a'\*2，b\*3，c\*5，我们需要从中间挑一个最小的。其中a‘是从a更新得到的，而b和c都不用变，直接带入了下一轮的竞争。

所以我们用三个指针idx2,idx3,idx5。idx2表示当前已经生成的所有丑数里面，最小的一个数的index，能够使得nums[idx2]\*2是一个未加入的新丑数。同理我们可以定义idx3和idx5.这样，下一个未加入的新丑数，只能在三个候选中产生，那就是nums[idx2]\*2,nums[idx3]\*3,nums[idx5]\*5. 我们挑选其中最小的一个加入nums之后，对应的idx就需要自加一。需要特别注意的，当有多个候选并列最小的时候，说明我们可能不只有一个idx需要更新。


[Leetcode Link](https://leetcode.com/problems/ugly-number-ii)