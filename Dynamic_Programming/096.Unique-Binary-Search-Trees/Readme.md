### 096.Unique-Binary-Search-Trees

首先我们考虑根节点的选择。如果我们选择数字k作为根节点，那么左子树必然由节点`1~k-1`组成，左子树必然由节点`k+1~n`组成。接下来左右子树的构建就是一个递归问题。构建完左右子树之后，以k为根节点的BST的个数就是左子树个数乘以右子树个数（两两组合）。

我们可以用dp的解法。令dp[k]表示给定n个节点可以构成多少个BST。根据上面的思路，我们先loop作为根节点的数值，然后递归调用dp
```cpp
dp[n] = 0;
for (int k=1; k<=n; k++)
  dp[n] += dp[k-1]*dp[n-1-k]; 
```
以上得到的序列```h[0]=1, h[1]=1, h[2]=3, h[3]=5, ...```就是著名的Catalan数。

Catalan数其实有更肩接的递归公式和通项公式：
```
h(n) =  h(n-1) * (4n-2)/(n+1)
h(n) =  C(2n,n) - C(2n, n-1),  其中C是组合数
```

类似的题目有很多.

#### follow up 1
给你N个节点，能构造出多少种不同结构的树？

这个和给你N个元素的数列，能构造出多少种不同结构的BST没有区别。因为任何一种普通树，只要合理填充节点val，都可以是BST。

#### follow up 2
给你n对括号，能构造出多少合法的序列？

我们考虑第一对括号里面包含多少个nested括号？假设是k个，那么第一对括号之后，需要构造一个有n-1-k对括号组成的合法序列。遍历所有k的可能，可以得到类似的dp转移方程：
```cpp
for (int k=0; k<=n-1; k++)
  dp[n] += dp[k]*dp[n-1-k]; 
```
答案依然是Catalan数h(n).

#### follow up 3
满二叉树定义是：每个节点要么是叶子节点，要么有两个子节点。如果节点总数是2n+1. 问能构造出多少不同结构的满二叉树？

首先想一下为什么节点总数是奇数？是因为满二叉树里，除了根节点，所有的节点都会有姐妹；所以算上根节点，总数必然是奇数个。OK，接下来，节点数目是2n+1的树，边的个数一定是2n。同理分析，每一条边必然也会有它的姐妹，也就是每一条指向左孩子的边，都会有一条指向右孩子的边。

我们现在只需要想象一下进行先序遍历时，走边的过程。假设指向左孩子的边对应左括号，指向有孩子的边对应右括号，那么每种不同结构的满二叉树的先序遍历（先走左边，再走右边），都一一对应着一种合法的左右括号序列。考虑到2n条边对应着n对括号，所以此题的答案还是Catalan数h(n)。

这道题还可以变形为：如果叶子节点总数是n+1，问能构造出多少不同结构的满二叉树？
